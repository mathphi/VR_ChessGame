<!DOCTYPE html>
<html>

<head>
</head>

<body>
<canvas id="webgl_canvas" width="800" height="600"></canvas>
<div id="fps"></div>
<div id="camera_mat"></div>
<div id="proj_mat"></div>

<script src="../../lib/gl-matrix-min.js"></script>
<script type="text/javascript" src="../../lib/camera.js"></script>
<script type="text/javascript" src="../../lib/shaders.js"></script>
<script type="text/javascript" src="../../lib/lights.js"></script>
<script type="text/javascript" src="../../lib/objects.js"></script>
<script type="text/javascript" src="../../lib/bump_mapping.js"></script>
<script type="text/javascript" src="../../lib/textures.js"></script>
<script>
    async function main() {
        // Boilerplate code
        const canvas = document.getElementById('webgl_canvas');
        const c_width = canvas.width;
        const c_height = canvas.height;
        const gl = canvas.getContext('webgl');

        // Enable tests for better rendering
        gl.enable(gl.DEPTH_TEST);
        //gl.enable(gl.CULL_FACE); // cull hidden faces behind normals!

        // Compile a shader program from the sources of "common_shader"
        const shader_common = await make_shader(gl, 'common_shader', '../../shaders');

        // loading the object from a file
        const cube = await load_obj('../objects/cube.obj');
        const plane = await load_obj('../objects/plane.obj');
        const sphere3 = await load_obj('../objects/torus.obj');

        // Load bump map
        const bump_map_cube = await load_texture(gl, '../textures/BumpMapCube.png');
        const bump_map = await load_texture(gl, '../textures/BumpMap.png');

        // Load textures
        const texture_cube = await load_texture(gl, '../textures/TextureCube.png');

        // Asynchronous call, we waited till the object was ready
        // Make the buffer and the functions to draw the object:
        const o1_mesh = await make_object(gl, cube, texture_cube, bump_map_cube);
        const o2_mesh = await make_object(gl, plane, null, bump_map);
        const o3_mesh = await make_object(gl, sphere3);

        // Translate the spheres
        o1_mesh.model = glMatrix.mat4.rotateX(o1_mesh.model,o1_mesh.model, Math.PI/2.0);
        o1_mesh.model = glMatrix.mat4.translate(o1_mesh.model,o1_mesh.model,
            glMatrix.vec3.fromValues(2.3, 0.0, 0.0));
        o2_mesh.model = glMatrix.mat4.rotateX(o2_mesh.model,o2_mesh.model, Math.PI/2.0);
        //o3_mesh.model = glMatrix.mat4.rotateX(o3_mesh.model,o3_mesh.model, Math.PI/2.0);
        o3_mesh.model = glMatrix.mat4.translate(o3_mesh.model,o3_mesh.model,
            glMatrix.vec3.fromValues(-2.3, 0.0, 0.0));

        // We define a light set (set of lights with some properties)
        // WARNING: shader code designed for max 10 lights !
        const lights_set = make_lights_set(gl);
        // Light 1
        lights_set.add_light(
            glMatrix.vec3.fromValues(3.0, 2.0, -6.0),
            glMatrix.vec3.fromValues(0.9, 0.1, 0.2),
            1.0
        );
        // Light 2
        lights_set.add_light(
            glMatrix.vec3.fromValues(-4.0, 6.0, 0.0),
            glMatrix.vec3.fromValues(0.1, 0.2, 0.9),
            1.0
        );
        // Light 3
        lights_set.add_light(
            glMatrix.vec3.fromValues(-2.0, 5.0, 6.0),
            glMatrix.vec3.fromValues(0.2, 1.0, 0.1),
            0.5
        );

        // Camera initial values
        const world_center  = glMatrix.vec3.fromValues(0.0, 0.0, 0.0);
        const world_up      = glMatrix.vec3.fromValues(0.0, 0.0, 1.0);
        const zenith        = 90.0;
        const azimuth       = 90.0;
        const radius        = 10.0;

        // Create camera
        const camera = make_camera(
            canvas,
            radius, zenith, azimuth,
            world_up, world_center);

        // Get camera projection
        const projection = camera.get_projection(45.0, c_width / c_height, 0.01, 100.0);

        // We need the camera position
        const u_cam_pos = gl.getUniformLocation(shader_common.program, 'u_cam_pos');

        function animate(time) {
            //Draw loop
            gl.clearColor(0.2, 0.2, 0.2, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // We use the "normal shader"
            shader_common.use();
            shader_common.set_projection_uniform(projection);
            shader_common.set_view_uniform(camera.get_view_matrix());

            // Activate lights in shader
            lights_set.activate(shader_common);

            // Add the viewer position
            gl.uniform3fv(u_cam_pos, camera.get_position());

            o1_mesh.activate(shader_common);
            o1_mesh.draw();

            // We use the same shader to draw the second sphere
            o2_mesh.activate(shader_common);
            o2_mesh.draw();

            o3_mesh.activate(shader_common);
            o3_mesh.draw();

            fps(time);
            window.requestAnimationFrame(animate); // While(True) loop!
        }

        //
        // FPS counter
        //
        let prev = 0;
        const fpsElem = document.querySelector("#fps");
        function fps(now) {
            now *= 0.001;
            const deltaTime = now - prev;
            prev = now;
            const fps = 1 / deltaTime;
            fpsElem.textContent = 'FPS: ' + fps.toFixed(1);
            return fps;
        }

        animate(0);
    }

    main();
</script>
</body>

</html>
