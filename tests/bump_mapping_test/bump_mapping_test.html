<!DOCTYPE html>
<html>

<head>
</head>

<body>
<!--
<h1>Light - Implement the complete light equation</h1>
<p>You can even add several lights with different colors and attenuation factors</p>
<p>Warning: correction uses only a very simplified light equation</p>
<p>You can do way better!</p>
<p>Main steps:</p>
<ul>
    <li>1) Load an object</li>
    <li>2) Write the shaders</li>
    <li>3) Define useful vector and matrices for the shaders</li>
    <li>4) Write the rendering loop</li>
</ul>
-->
<canvas id="webgl_canvas" width="800" height="600"></canvas>
<div id="fps"></div>
<div id="camera_mat"></div>
<div id="proj_mat"></div>

<script src="../../lib/gl-matrix-min.js"></script>
<script type="text/javascript" src="../../lib/camera.js"></script>
<script type="text/javascript" src="../../lib/shaders.js"></script>
<script type="text/javascript" src="../../lib/lights.js"></script>
<script type="text/javascript" src="../../lib/objects.js"></script>
<script type="text/javascript" src="../../lib/bump_mapping.js"></script>
<script type="text/javascript" src="../../lib/textures.js"></script>
<script>
    async function main() {
        // Boilerplate code
        const canvas = document.getElementById('webgl_canvas');
        const c_width = canvas.width;
        const c_height = canvas.height;
        const gl = canvas.getContext('webgl');

        // Enable tests for better rendering
        gl.enable(gl.DEPTH_TEST);
        //gl.enable(gl.CULL_FACE); // cull hidden faces behind normals!

        const sourceV = `
          attribute vec3 a_position;
          attribute vec2 a_texcoord;
          attribute vec3 a_normal;
          attribute vec3 a_tangent;
          attribute vec3 a_bitangent;

          varying vec3 v_normal;
          varying vec3 v_frag_coord;
          varying mat3 v_TBN;
          varying vec2 v_texcoord;

          uniform mat4 M;
          uniform mat4 itM;  // inverse transpose model!
          uniform mat4 V;
          uniform mat4 P;

          void main() {
            // 2) Shader code
            vec4 frag_coord = M*vec4(a_position, 1.0);
            gl_Position = P*V*frag_coord;

            // Transform correctly the normals!
            v_normal = vec3(itM * vec4(a_normal, 1.0));

            // Compute the TBN space for this vertex
            vec3 T = normalize(vec3(M * vec4(a_tangent,   0.0)));
            vec3 B = normalize(vec3(M * vec4(a_bitangent, 0.0)));
            vec3 N = normalize(v_normal);
            v_TBN = mat3(T, B, N);

            v_texcoord    = a_texcoord;
            v_frag_coord  = frag_coord.xyz;
          }
        `;

        const sourceF = `
          #define MAX_LIGHTS_COUNT 10

          precision mediump float;
          varying vec3 v_normal;
          varying vec3 v_frag_coord;
          varying mat3 v_TBN;
          varying vec2 v_texcoord;

          uniform int u_lights_count;
          uniform vec3 u_lights_position[MAX_LIGHTS_COUNT];
          uniform vec3 u_lights_color[MAX_LIGHTS_COUNT];
          uniform float u_lights_intensity[MAX_LIGHTS_COUNT];
          uniform vec3 u_view_dir;

          uniform bool u_has_texture;
          uniform bool u_has_bumpmap;
          uniform sampler2D u_texture;
          uniform sampler2D u_bump_map;

          void main() {
            // Check is we must apply a bump map
            vec3 normal;
            if (u_has_bumpmap) {
                normal = texture2D(u_bump_map, vec2(v_texcoord.x, 1.0-v_texcoord.y)).rgb;
                normal = normal * 2.0 - 1.0;    // From color space to normal space
                normal = normalize(v_TBN * normal);
            }
            else {
                normal = normalize(v_normal);
            }

            // Ambient
            float ambient = 0.1;

            // Light contribution
            vec3 light = vec3(0);

            // For each light
            for (int i = 0 ; i < MAX_LIGHTS_COUNT ; i++) {
                // Needed to exit the loop since loop condition must depend
                // on constant variables only!
                if (i >= u_lights_count) {
                    break;
                }

                // light color
                vec3 light_color = u_lights_color[i];

                // Light position
                vec3 light_position = u_lights_position[i];

                // Light intensity
                float light_intensity = u_lights_intensity[i];

                // Light vector to fragment
                vec3 L = normalize(light_position - v_frag_coord);

                // Diffuse
                float diffusion = max(0.0, dot(normal, L));

                // specular
                float spec_strength = 0.8;
                vec3 view_dir = normalize(u_view_dir - v_frag_coord);
                vec3 reflect_dir = reflect(-L, normal);
                float spec = pow(max(dot(view_dir, reflect_dir), 0.0), 32.0);
                float specular = spec_strength * spec;

                // Attenuation as a function of the distance
                //float dist_att = min(1.0, 1.0 / distance(light_position, v_frag_coord));

                light += (specular + diffusion) * light_color * light_intensity;// * dist_att;
            }

            vec4 color = vec4(1.0);

            // If we must paint with a texture...
            if (u_has_texture) {
                color = texture2D(u_texture, vec2(v_texcoord.x, 1.0-v_texcoord.y));
            }

            gl_FragColor = color * vec4(ambient + light, 1.0);
          }
        `;

        const shader_ph_spec = make_shader(gl, sourceV, sourceF);

        // 1) Load an object
        // loading the object from a file
        const cube = await load_obj('../objects/cube.obj');
        const plane = await load_obj('../objects/plane.obj');
        const sphere3 = await load_obj('../objects/sphere_smooth.obj');

        // Load bump map
        const bump_map_cube = await load_texture(gl, '../textures/BumpMapCube.png');
        const bump_map = await load_texture(gl, '../textures/BumpMap.png');

        // Load textures
        const texture_cube = await load_texture(gl, '../textures/TextureCube.png');

        // Asynchronous call, we waited till the object was ready
        // Make the buffer and the functions to draw the object:
        const o1_mesh = await make_object(gl, cube, texture_cube, bump_map_cube);
        const o2_mesh = await make_object(gl, plane, null, bump_map);
        const o3_mesh = await make_object(gl, sphere3);

        // Translate the spheres
        o1_mesh.model = glMatrix.mat4.rotateX(o1_mesh.model,o1_mesh.model, Math.PI/2.0);
        o1_mesh.model = glMatrix.mat4.translate(o1_mesh.model,o1_mesh.model,
            glMatrix.vec3.fromValues(2.3, 0.0, 0.0));
        o2_mesh.model = glMatrix.mat4.rotateX(o2_mesh.model,o2_mesh.model, Math.PI/2.0);
        o3_mesh.model = glMatrix.mat4.rotateX(o3_mesh.model,o3_mesh.model, Math.PI/2.0);
        o3_mesh.model = glMatrix.mat4.translate(o3_mesh.model,o3_mesh.model,
            glMatrix.vec3.fromValues(-2.3, 0.0, 0.0));

        // 3) Define all the variables you will need to perform the computations
        //    in the shaders here! (light, useful matrices, ...)

        // We define a light in space and retrieve its ID in the shader
        // WARNING: shader code designed for max 10 lights !
        const lights_set = make_lights_set();
        // Light 1
        lights_set.add_light(
            glMatrix.vec3.fromValues(3.0, 2.0, -6.0),
            glMatrix.vec3.fromValues(0.9, 0.1, 0.2),
            1.0
        );
        // Light 2
        lights_set.add_light(
            glMatrix.vec3.fromValues(-4.0, 6.0, 0.0),
            glMatrix.vec3.fromValues(0.1, 0.2, 0.9),
            1.0
        );
        // Light 3
        lights_set.add_light(
            glMatrix.vec3.fromValues(-2.0, 5.0, 6.0),
            glMatrix.vec3.fromValues(0.2, 1.0, 0.1),
            0.5
        );

        const u_lights_count = gl.getUniformLocation(shader_ph_spec.program, 'u_lights_count');
        const u_lights_pos   = gl.getUniformLocation(shader_ph_spec.program, 'u_lights_position');
        const u_lights_color = gl.getUniformLocation(shader_ph_spec.program, 'u_lights_color');
        const u_lights_int   = gl.getUniformLocation(shader_ph_spec.program, 'u_lights_intensity');

        // We need to send the inverse transpose of the model matrix for the model
        const u_itM = gl.getUniformLocation(shader_ph_spec.program, 'itM');

        // We need the camera position
        const u_view_dir = gl.getUniformLocation(shader_ph_spec.program, 'u_view_dir');

        // Camera initial values
        const world_center  = glMatrix.vec3.fromValues(0.0, 0.0, 0.0);
        const world_up      = glMatrix.vec3.fromValues(0.0, 0.0, 1.0);
        const zenith        = 90.0;
        const azimuth       = 90.0;
        const radius        = 10.0;

        // Create camera
        const camera = make_camera(
            canvas,
            radius, zenith, azimuth,
            world_up, world_center);

        // Get camera projection
        const projection = camera.get_projection(45.0, c_width / c_height, 0.01, 100.0);

        function animate(time) {
            //Draw loop
            gl.clearColor(0.2, 0.2, 0.2, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // 4) Write the code to draw the scene
            //    Don't forget to send all elements you need in the shaders!

            shader_ph_spec.use();
            var unif = shader_ph_spec.get_uniforms();
            view = camera.get_view_matrix();
            gl.uniformMatrix4fv(unif['view'], false, view);
            gl.uniformMatrix4fv(unif['proj'], false, projection);
            // Send data for all lights to the shader
            gl.uniform1i(u_lights_count,  lights_set.lights_count());
            gl.uniform3fv(u_lights_pos,   lights_set.get_positions());
            gl.uniform3fv(u_lights_color, lights_set.get_colors());
            gl.uniform1fv(u_lights_int,   lights_set.get_intensities());

            // Add the viewer position
            // Set one time the camera position for all the shaders
            gl.uniform3fv(u_view_dir, camera.get_position());

            o1_mesh.activate(shader_ph_spec);
            gl.uniformMatrix4fv(unif['model'], false, o1_mesh.model);
            var itM = glMatrix.mat4.create();
            itM = glMatrix.mat4.invert(itM, o1_mesh.model);
            itM = glMatrix.mat4.transpose(itM, itM);
            gl.uniformMatrix4fv(u_itM, false, itM);
            o1_mesh.draw();

            // We use the same shader to draw the second sphere
            o2_mesh.activate(shader_ph_spec);
            // Only the model matrix changes!
            gl.uniformMatrix4fv(unif['model'], false, o2_mesh.model);
            itM = glMatrix.mat4.invert(itM, o2_mesh.model);
            itM = glMatrix.mat4.transpose(itM, itM);
            gl.uniformMatrix4fv(u_itM, false, itM);
            o2_mesh.draw();

            o3_mesh.activate(shader_ph_spec);
            // Only the model matrix changes!
            gl.uniformMatrix4fv(unif['model'], false, o3_mesh.model);
            itM = glMatrix.mat4.invert(itM, o3_mesh.model);
            itM = glMatrix.mat4.transpose(itM, itM);
            gl.uniformMatrix4fv(u_itM, false, itM);
            o3_mesh.draw();

            fps(time);
            window.requestAnimationFrame(animate); // While(True) loop!
        }

        var prev = 0
        const fpsElem = document.querySelector("#fps");

        function fps(now) {
            now *= 0.001;
            const deltaTime = now - prev;
            prev = now;
            const fps = 1 / deltaTime;
            fpsElem.textContent = 'FPS: ' + fps.toFixed(1);
            return fps;
        }

        animate(0);
    }

    main();
</script>
</body>

</html>
